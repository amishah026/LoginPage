{"ast":null,"code":"\"use strict\";\n\n/**\n * @module LRUCache\n */\nvar _asyncToGenerator = require(\"C:/Users/User/Desktop/frontend/LoginApp/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classPrivateMethodInitSpec = require(\"C:/Users/User/Desktop/frontend/LoginApp/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"C:/Users/User/Desktop/frontend/LoginApp/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldSet = require(\"C:/Users/User/Desktop/frontend/LoginApp/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateMethodGet = require(\"C:/Users/User/Desktop/frontend/LoginApp/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldGet = require(\"C:/Users/User/Desktop/frontend/LoginApp/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _defineProperty = require(\"C:/Users/User/Desktop/frontend/LoginApp/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classStaticPrivateFieldSpecGet = require(\"C:/Users/User/Desktop/frontend/LoginApp/node_modules/@babel/runtime/helpers/classStaticPrivateFieldSpecGet.js\").default;\nvar _classStaticPrivateFieldSpecSet = require(\"C:/Users/User/Desktop/frontend/LoginApp/node_modules/@babel/runtime/helpers/classStaticPrivateFieldSpecSet.js\").default;\nlet _Symbol$iterator;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LRUCache = void 0;\nconst perf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;\nconst warned = new Set();\nconst emitWarning = (msg, type, code, fn) => {\n  typeof process === 'object' && process && typeof process.emitWarning === 'function' ? process.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);\n};\nconst shouldWarn = code => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = max => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size);\n    this.fill(0);\n  }\n}\nclass Stack {\n  static create(max) {\n    const HeapCls = getUintArray(max);\n    if (!HeapCls) return [];\n    _classStaticPrivateFieldSpecSet(Stack, Stack, _constructing, true);\n    const s = new Stack(max, HeapCls);\n    _classStaticPrivateFieldSpecSet(Stack, Stack, _constructing, false);\n    return s;\n  }\n  constructor(max, HeapCls) {\n    _defineProperty(this, \"heap\", void 0);\n    _defineProperty(this, \"length\", void 0);\n    /* c8 ignore start */\n    if (!_classStaticPrivateFieldSpecGet(Stack, Stack, _constructing)) {\n      throw new TypeError('instantiate Stack using Stack.create(n)');\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max);\n    this.length = 0;\n  }\n  push(n) {\n    this.heap[this.length++] = n;\n  }\n  pop() {\n    return this.heap[--this.length];\n  }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\n// private constructor\nvar _constructing = {\n  writable: true,\n  value: false\n};\nvar _max = /*#__PURE__*/new WeakMap();\nvar _maxSize = /*#__PURE__*/new WeakMap();\nvar _dispose = /*#__PURE__*/new WeakMap();\nvar _disposeAfter = /*#__PURE__*/new WeakMap();\nvar _fetchMethod = /*#__PURE__*/new WeakMap();\nvar _size = /*#__PURE__*/new WeakMap();\nvar _calculatedSize = /*#__PURE__*/new WeakMap();\nvar _keyMap = /*#__PURE__*/new WeakMap();\nvar _keyList = /*#__PURE__*/new WeakMap();\nvar _valList = /*#__PURE__*/new WeakMap();\nvar _next = /*#__PURE__*/new WeakMap();\nvar _prev = /*#__PURE__*/new WeakMap();\nvar _head = /*#__PURE__*/new WeakMap();\nvar _tail = /*#__PURE__*/new WeakMap();\nvar _free = /*#__PURE__*/new WeakMap();\nvar _disposed = /*#__PURE__*/new WeakMap();\nvar _sizes = /*#__PURE__*/new WeakMap();\nvar _starts = /*#__PURE__*/new WeakMap();\nvar _ttls = /*#__PURE__*/new WeakMap();\nvar _hasDispose = /*#__PURE__*/new WeakMap();\nvar _hasFetchMethod = /*#__PURE__*/new WeakMap();\nvar _hasDisposeAfter = /*#__PURE__*/new WeakMap();\nvar _initializeTTLTracking = /*#__PURE__*/new WeakSet();\nvar _updateItemAge = /*#__PURE__*/new WeakMap();\nvar _statusTTL = /*#__PURE__*/new WeakMap();\nvar _setItemTTL = /*#__PURE__*/new WeakMap();\nvar _isStale = /*#__PURE__*/new WeakMap();\nvar _initializeSizeTracking = /*#__PURE__*/new WeakSet();\nvar _removeItemSize = /*#__PURE__*/new WeakMap();\nvar _addItemSize = /*#__PURE__*/new WeakMap();\nvar _requireSize = /*#__PURE__*/new WeakMap();\nvar _indexes = /*#__PURE__*/new WeakSet();\nvar _rindexes = /*#__PURE__*/new WeakSet();\nvar _isValidIndex = /*#__PURE__*/new WeakSet();\nvar _evict = /*#__PURE__*/new WeakSet();\nvar _backgroundFetch = /*#__PURE__*/new WeakSet();\nvar _isBackgroundFetch = /*#__PURE__*/new WeakSet();\nvar _connect = /*#__PURE__*/new WeakSet();\nvar _moveToTail = /*#__PURE__*/new WeakSet();\n_Symbol$iterator = Symbol.iterator;\nclass LRUCache {\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals(c) {\n    return {\n      // properties\n      starts: _classPrivateFieldGet(c, _starts),\n      ttls: _classPrivateFieldGet(c, _ttls),\n      sizes: _classPrivateFieldGet(c, _sizes),\n      keyMap: _classPrivateFieldGet(c, _keyMap),\n      keyList: _classPrivateFieldGet(c, _keyList),\n      valList: _classPrivateFieldGet(c, _valList),\n      next: _classPrivateFieldGet(c, _next),\n      prev: _classPrivateFieldGet(c, _prev),\n      get head() {\n        return _classPrivateFieldGet(c, _head);\n      },\n      get tail() {\n        return _classPrivateFieldGet(c, _tail);\n      },\n      free: _classPrivateFieldGet(c, _free),\n      // methods\n      isBackgroundFetch: p => _classPrivateMethodGet(c, _isBackgroundFetch, _isBackgroundFetch2).call(c, p),\n      backgroundFetch: (k, index, options, context) => _classPrivateMethodGet(c, _backgroundFetch, _backgroundFetch2).call(c, k, index, options, context),\n      moveToTail: index => _classPrivateMethodGet(c, _moveToTail, _moveToTail2).call(c, index),\n      indexes: options => _classPrivateMethodGet(c, _indexes, _indexes2).call(c, options),\n      rindexes: options => _classPrivateMethodGet(c, _rindexes, _rindexes2).call(c, options),\n      isStale: index => _classPrivateFieldGet(c, _isStale).call(c, index)\n    };\n  }\n  // Protected read-only members\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max() {\n    return _classPrivateFieldGet(this, _max);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize() {\n    return _classPrivateFieldGet(this, _maxSize);\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize() {\n    return _classPrivateFieldGet(this, _calculatedSize);\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size() {\n    return _classPrivateFieldGet(this, _size);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod() {\n    return _classPrivateFieldGet(this, _fetchMethod);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return _classPrivateFieldGet(this, _dispose);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return _classPrivateFieldGet(this, _disposeAfter);\n  }\n  constructor(_options) {\n    _classPrivateMethodInitSpec(this, _moveToTail);\n    _classPrivateMethodInitSpec(this, _connect);\n    _classPrivateMethodInitSpec(this, _isBackgroundFetch);\n    _classPrivateMethodInitSpec(this, _backgroundFetch);\n    _classPrivateMethodInitSpec(this, _evict);\n    _classPrivateMethodInitSpec(this, _isValidIndex);\n    _classPrivateMethodInitSpec(this, _rindexes);\n    _classPrivateMethodInitSpec(this, _indexes);\n    _classPrivateMethodInitSpec(this, _initializeSizeTracking);\n    _classPrivateMethodInitSpec(this, _initializeTTLTracking);\n    // properties coming in from the options of these, only max and maxSize\n    // really *need* to be protected. The rest can be modified, as they just\n    // set defaults for various methods.\n    _classPrivateFieldInitSpec(this, _max, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _maxSize, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _dispose, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _disposeAfter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _fetchMethod, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    _defineProperty(this, \"ttl\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    _defineProperty(this, \"ttlResolution\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    _defineProperty(this, \"ttlAutopurge\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    _defineProperty(this, \"updateAgeOnGet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    _defineProperty(this, \"updateAgeOnHas\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    _defineProperty(this, \"allowStale\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    _defineProperty(this, \"noDisposeOnSet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    _defineProperty(this, \"noUpdateTTL\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    _defineProperty(this, \"maxEntrySize\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    _defineProperty(this, \"sizeCalculation\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    _defineProperty(this, \"noDeleteOnFetchRejection\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    _defineProperty(this, \"noDeleteOnStaleGet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    _defineProperty(this, \"allowStaleOnFetchAbort\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    _defineProperty(this, \"allowStaleOnFetchRejection\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    _defineProperty(this, \"ignoreFetchAbort\", void 0);\n    // computed properties\n    _classPrivateFieldInitSpec(this, _size, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _calculatedSize, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _keyMap, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _keyList, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _valList, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _next, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _prev, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _head, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _tail, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _free, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _disposed, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _sizes, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _starts, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _ttls, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hasDispose, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hasFetchMethod, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hasDisposeAfter, {\n      writable: true,\n      value: void 0\n    });\n    // conditionally set private methods related to TTL\n    _classPrivateFieldInitSpec(this, _updateItemAge, {\n      writable: true,\n      value: () => {}\n    });\n    _classPrivateFieldInitSpec(this, _statusTTL, {\n      writable: true,\n      value: () => {}\n    });\n    _classPrivateFieldInitSpec(this, _setItemTTL, {\n      writable: true,\n      value: () => {}\n    });\n    /* c8 ignore stop */\n    _classPrivateFieldInitSpec(this, _isStale, {\n      writable: true,\n      value: () => false\n    });\n    _classPrivateFieldInitSpec(this, _removeItemSize, {\n      writable: true,\n      value: _i => {}\n    });\n    _classPrivateFieldInitSpec(this, _addItemSize, {\n      writable: true,\n      value: (_i, _s, _st) => {}\n    });\n    _classPrivateFieldInitSpec(this, _requireSize, {\n      writable: true,\n      value: (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n          throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n      }\n    });\n    const {\n      max = 0,\n      ttl: _ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale: _allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize: _maxSize2 = 0,\n      maxEntrySize = 0,\n      sizeCalculation: _sizeCalculation,\n      fetchMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort\n    } = _options;\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer');\n    }\n    const UintArray = max ? getUintArray(max) : Array;\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max);\n    }\n    _classPrivateFieldSet(this, _max, max);\n    _classPrivateFieldSet(this, _maxSize, _maxSize2);\n    this.maxEntrySize = maxEntrySize || _classPrivateFieldGet(this, _maxSize);\n    this.sizeCalculation = _sizeCalculation;\n    if (this.sizeCalculation) {\n      if (!_classPrivateFieldGet(this, _maxSize) && !this.maxEntrySize) {\n        throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function');\n      }\n    }\n    if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {\n      throw new TypeError('fetchMethod must be a function if specified');\n    }\n    _classPrivateFieldSet(this, _fetchMethod, fetchMethod);\n    _classPrivateFieldSet(this, _hasFetchMethod, !!fetchMethod);\n    _classPrivateFieldSet(this, _keyMap, new Map());\n    _classPrivateFieldSet(this, _keyList, new Array(max).fill(undefined));\n    _classPrivateFieldSet(this, _valList, new Array(max).fill(undefined));\n    _classPrivateFieldSet(this, _next, new UintArray(max));\n    _classPrivateFieldSet(this, _prev, new UintArray(max));\n    _classPrivateFieldSet(this, _head, 0);\n    _classPrivateFieldSet(this, _tail, 0);\n    _classPrivateFieldSet(this, _free, Stack.create(max));\n    _classPrivateFieldSet(this, _size, 0);\n    _classPrivateFieldSet(this, _calculatedSize, 0);\n    if (typeof dispose === 'function') {\n      _classPrivateFieldSet(this, _dispose, dispose);\n    }\n    if (typeof disposeAfter === 'function') {\n      _classPrivateFieldSet(this, _disposeAfter, disposeAfter);\n      _classPrivateFieldSet(this, _disposed, []);\n    } else {\n      _classPrivateFieldSet(this, _disposeAfter, undefined);\n      _classPrivateFieldSet(this, _disposed, undefined);\n    }\n    _classPrivateFieldSet(this, _hasDispose, !!_classPrivateFieldGet(this, _dispose));\n    _classPrivateFieldSet(this, _hasDisposeAfter, !!_classPrivateFieldGet(this, _disposeAfter));\n    this.noDisposeOnSet = !!noDisposeOnSet;\n    this.noUpdateTTL = !!noUpdateTTL;\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n    this.ignoreFetchAbort = !!ignoreFetchAbort;\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (_classPrivateFieldGet(this, _maxSize) !== 0) {\n        if (!isPosInt(_classPrivateFieldGet(this, _maxSize))) {\n          throw new TypeError('maxSize must be a positive integer if specified');\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError('maxEntrySize must be a positive integer if specified');\n      }\n      _classPrivateMethodGet(this, _initializeSizeTracking, _initializeSizeTracking2).call(this);\n    }\n    this.allowStale = !!_allowStale;\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n    this.updateAgeOnGet = !!updateAgeOnGet;\n    this.updateAgeOnHas = !!updateAgeOnHas;\n    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n    this.ttlAutopurge = !!ttlAutopurge;\n    this.ttl = _ttl || 0;\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError('ttl must be a positive integer if specified');\n      }\n      _classPrivateMethodGet(this, _initializeTTLTracking, _initializeTTLTracking2).call(this);\n    }\n    // do not allow completely unbounded caches\n    if (_classPrivateFieldGet(this, _max) === 0 && this.ttl === 0 && _classPrivateFieldGet(this, _maxSize) === 0) {\n      throw new TypeError('At least one of max, maxSize, or ttl is required');\n    }\n    if (!this.ttlAutopurge && !_classPrivateFieldGet(this, _max) && !_classPrivateFieldGet(this, _maxSize)) {\n      const code = 'LRU_CACHE_UNBOUNDED';\n      if (shouldWarn(code)) {\n        warned.add(code);\n        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n      }\n    }\n  }\n  /**\n   * Return the remaining TTL time for a given entry key\n   */\n  getRemainingTTL(key) {\n    return _classPrivateFieldGet(this, _keyMap).has(key) ? Infinity : 0;\n  }\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      if (_classPrivateFieldGet(this, _valList)[i] !== undefined && _classPrivateFieldGet(this, _keyList)[i] !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield [_classPrivateFieldGet(this, _keyList)[i], _classPrivateFieldGet(this, _valList)[i]];\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      if (_classPrivateFieldGet(this, _valList)[i] !== undefined && _classPrivateFieldGet(this, _keyList)[i] !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield [_classPrivateFieldGet(this, _keyList)[i], _classPrivateFieldGet(this, _valList)[i]];\n      }\n    }\n  }\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const k = _classPrivateFieldGet(this, _keyList)[i];\n      if (k !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield k;\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      const k = _classPrivateFieldGet(this, _keyList)[i];\n      if (k !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield k;\n      }\n    }\n  }\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      if (v !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield _classPrivateFieldGet(this, _valList)[i];\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      if (v !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield _classPrivateFieldGet(this, _valList)[i];\n      }\n    }\n  }\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [_Symbol$iterator]() {\n    return this.entries();\n  }\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to Array.find().  fn is called as fn(value, key, cache).\n   */\n  find(fn, getOptions = {}) {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      if (fn(value, _classPrivateFieldGet(this, _keyList)[i], this)) {\n        return this.get(_classPrivateFieldGet(this, _keyList)[i], getOptions);\n      }\n    }\n  }\n  /**\n   * Call the supplied function on each item in the cache, in order from\n   * most recently used to least recently used.  fn is called as\n   * fn(value, key, cache).  Does not update age or recenty of use.\n   * Does not iterate over stale values.\n   */\n  forEach(fn, thisp = this) {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, _classPrivateFieldGet(this, _keyList)[i], this);\n    }\n  }\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(fn, thisp = this) {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, _classPrivateFieldGet(this, _keyList)[i], this);\n    }\n  }\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false;\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this, {\n      allowStale: true\n    })) {\n      if (_classPrivateFieldGet(this, _isStale).call(this, i)) {\n        this.delete(_classPrivateFieldGet(this, _keyList)[i]);\n        deleted = true;\n      }\n    }\n    return deleted;\n  }\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to cache.load()\n   */\n  dump() {\n    const arr = [];\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this, {\n      allowStale: true\n    })) {\n      const key = _classPrivateFieldGet(this, _keyList)[i];\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined || key === undefined) continue;\n      const entry = {\n        value\n      };\n      if (_classPrivateFieldGet(this, _ttls) && _classPrivateFieldGet(this, _starts)) {\n        entry.ttl = _classPrivateFieldGet(this, _ttls)[i];\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - _classPrivateFieldGet(this, _starts)[i];\n        entry.start = Math.floor(Date.now() - age);\n      }\n      if (_classPrivateFieldGet(this, _sizes)) {\n        entry.size = _classPrivateFieldGet(this, _sizes)[i];\n      }\n      arr.unshift([key, entry]);\n    }\n    return arr;\n  }\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   * Note that the shape of the resulting cache may be different if the\n   * same options are not used in both caches.\n   */\n  load(arr) {\n    this.clear();\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start;\n        entry.start = perf.now() - age;\n      }\n      this.set(key, entry.value, entry);\n    }\n  }\n  /**\n   * Add a value to the cache.\n   */\n  set(k, v, setOptions = {}) {\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status\n    } = setOptions;\n    let {\n      noUpdateTTL = this.noUpdateTTL\n    } = setOptions;\n    const size = _classPrivateFieldGet(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss';\n        status.maxEntrySizeExceeded = true;\n      }\n      // have to delete, in case something is there already.\n      this.delete(k);\n      return this;\n    }\n    let index = _classPrivateFieldGet(this, _size) === 0 ? undefined : _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index === undefined) {\n      var _this$size, _this$size2;\n      // addition\n      index = _classPrivateFieldGet(this, _size) === 0 ? _classPrivateFieldGet(this, _tail) : _classPrivateFieldGet(this, _free).length !== 0 ? _classPrivateFieldGet(this, _free).pop() : _classPrivateFieldGet(this, _size) === _classPrivateFieldGet(this, _max) ? _classPrivateMethodGet(this, _evict, _evict2).call(this, false) : _classPrivateFieldGet(this, _size);\n      _classPrivateFieldGet(this, _keyList)[index] = k;\n      _classPrivateFieldGet(this, _valList)[index] = v;\n      _classPrivateFieldGet(this, _keyMap).set(k, index);\n      _classPrivateFieldGet(this, _next)[_classPrivateFieldGet(this, _tail)] = index;\n      _classPrivateFieldGet(this, _prev)[index] = _classPrivateFieldGet(this, _tail);\n      _classPrivateFieldSet(this, _tail, index);\n      _classPrivateFieldSet(this, _size, (_this$size = _classPrivateFieldGet(this, _size), _this$size2 = _this$size++, _this$size)), _this$size2;\n      _classPrivateFieldGet(this, _addItemSize).call(this, index, size, status);\n      if (status) status.set = 'add';\n      noUpdateTTL = false;\n    } else {\n      // update\n      _classPrivateMethodGet(this, _moveToTail, _moveToTail2).call(this, index);\n      const oldVal = _classPrivateFieldGet(this, _valList)[index];\n      if (v !== oldVal) {\n        if (_classPrivateFieldGet(this, _hasFetchMethod) && _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'));\n        } else if (!noDisposeOnSet) {\n          if (_classPrivateFieldGet(this, _hasDispose)) {\n            _classPrivateFieldGet(this, _dispose)?.call(this, oldVal, k, 'set');\n          }\n          if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n            _classPrivateFieldGet(this, _disposed)?.push([oldVal, k, 'set']);\n          }\n        }\n        _classPrivateFieldGet(this, _removeItemSize).call(this, index);\n        _classPrivateFieldGet(this, _addItemSize).call(this, index, size, status);\n        _classPrivateFieldGet(this, _valList)[index] = v;\n        if (status) {\n          status.set = 'replace';\n          const oldValue = oldVal && _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;\n          if (oldValue !== undefined) status.oldValue = oldValue;\n        }\n      } else if (status) {\n        status.set = 'update';\n      }\n    }\n    if (ttl !== 0 && !_classPrivateFieldGet(this, _ttls)) {\n      _classPrivateMethodGet(this, _initializeTTLTracking, _initializeTTLTracking2).call(this);\n    }\n    if (_classPrivateFieldGet(this, _ttls)) {\n      if (!noUpdateTTL) {\n        _classPrivateFieldGet(this, _setItemTTL).call(this, index, ttl, start);\n      }\n      if (status) _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n    }\n    if (!noDisposeOnSet && _classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)) {\n      const dt = _classPrivateFieldGet(this, _disposed);\n      let task;\n      while (task = dt?.shift()) {\n        _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n      }\n    }\n    return this;\n  }\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop() {\n    try {\n      while (_classPrivateFieldGet(this, _size)) {\n        const val = _classPrivateFieldGet(this, _valList)[_classPrivateFieldGet(this, _head)];\n        _classPrivateMethodGet(this, _evict, _evict2).call(this, true);\n        if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching;\n          }\n        } else if (val !== undefined) {\n          return val;\n        }\n      }\n    } finally {\n      if (_classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)) {\n        const dt = _classPrivateFieldGet(this, _disposed);\n        let task;\n        while (task = dt?.shift()) {\n          _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n        }\n      }\n    }\n  }\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k, hasOptions = {}) {\n    const {\n      updateAgeOnHas = this.updateAgeOnHas,\n      status\n    } = hasOptions;\n    const index = _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index !== undefined) {\n      const v = _classPrivateFieldGet(this, _valList)[index];\n      if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) && v.__staleWhileFetching === undefined) {\n        return false;\n      }\n      if (!_classPrivateFieldGet(this, _isStale).call(this, index)) {\n        if (updateAgeOnHas) {\n          _classPrivateFieldGet(this, _updateItemAge).call(this, index);\n        }\n        if (status) {\n          status.has = 'hit';\n          _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n        }\n        return true;\n      } else if (status) {\n        status.has = 'stale';\n        _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n      }\n    } else if (status) {\n      status.has = 'miss';\n    }\n    return false;\n  }\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k, peekOptions = {}) {\n    const {\n      allowStale = this.allowStale\n    } = peekOptions;\n    const index = _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index !== undefined && (allowStale || !_classPrivateFieldGet(this, _isStale).call(this, index))) {\n      const v = _classPrivateFieldGet(this, _valList)[index];\n      // either stale and allowed, or forcing a refresh of non-stale value\n      return _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n    }\n  }\n  fetch(k, fetchOptions = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        // get options\n        allowStale = _this.allowStale,\n        updateAgeOnGet = _this.updateAgeOnGet,\n        noDeleteOnStaleGet = _this.noDeleteOnStaleGet,\n        // set options\n        ttl = _this.ttl,\n        noDisposeOnSet = _this.noDisposeOnSet,\n        size = 0,\n        sizeCalculation = _this.sizeCalculation,\n        noUpdateTTL = _this.noUpdateTTL,\n        // fetch exclusive options\n        noDeleteOnFetchRejection = _this.noDeleteOnFetchRejection,\n        allowStaleOnFetchRejection = _this.allowStaleOnFetchRejection,\n        ignoreFetchAbort = _this.ignoreFetchAbort,\n        allowStaleOnFetchAbort = _this.allowStaleOnFetchAbort,\n        context,\n        forceRefresh = false,\n        status,\n        signal\n      } = fetchOptions;\n      if (!_classPrivateFieldGet(_this, _hasFetchMethod)) {\n        if (status) status.fetch = 'get';\n        return _this.get(k, {\n          allowStale,\n          updateAgeOnGet,\n          noDeleteOnStaleGet,\n          status\n        });\n      }\n      const options = {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        ttl,\n        noDisposeOnSet,\n        size,\n        sizeCalculation,\n        noUpdateTTL,\n        noDeleteOnFetchRejection,\n        allowStaleOnFetchRejection,\n        allowStaleOnFetchAbort,\n        ignoreFetchAbort,\n        status,\n        signal\n      };\n      let index = _classPrivateFieldGet(_this, _keyMap).get(k);\n      if (index === undefined) {\n        if (status) status.fetch = 'miss';\n        const p = _classPrivateMethodGet(_this, _backgroundFetch, _backgroundFetch2).call(_this, k, index, options, context);\n        return p.__returned = p;\n      } else {\n        // in cache, maybe already fetching\n        const v = _classPrivateFieldGet(_this, _valList)[index];\n        if (_classPrivateMethodGet(_this, _isBackgroundFetch, _isBackgroundFetch2).call(_this, v)) {\n          const stale = allowStale && v.__staleWhileFetching !== undefined;\n          if (status) {\n            status.fetch = 'inflight';\n            if (stale) status.returnedStale = true;\n          }\n          return stale ? v.__staleWhileFetching : v.__returned = v;\n        }\n        // if we force a refresh, that means do NOT serve the cached value,\n        // unless we are already in the process of refreshing the cache.\n        const isStale = _classPrivateFieldGet(_this, _isStale).call(_this, index);\n        if (!forceRefresh && !isStale) {\n          if (status) status.fetch = 'hit';\n          _classPrivateMethodGet(_this, _moveToTail, _moveToTail2).call(_this, index);\n          if (updateAgeOnGet) {\n            _classPrivateFieldGet(_this, _updateItemAge).call(_this, index);\n          }\n          if (status) _classPrivateFieldGet(_this, _statusTTL).call(_this, status, index);\n          return v;\n        }\n        // ok, it is stale or a forced refresh, and not already fetching.\n        // refresh the cache.\n        const p = _classPrivateMethodGet(_this, _backgroundFetch, _backgroundFetch2).call(_this, k, index, options, context);\n        const hasStale = p.__staleWhileFetching !== undefined;\n        const staleVal = hasStale && allowStale;\n        if (status) {\n          status.fetch = isStale ? 'stale' : 'refresh';\n          if (staleVal && isStale) status.returnedStale = true;\n        }\n        return staleVal ? p.__staleWhileFetching : p.__returned = p;\n      }\n    })();\n  }\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k, getOptions = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status\n    } = getOptions;\n    const index = _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index !== undefined) {\n      const value = _classPrivateFieldGet(this, _valList)[index];\n      const fetching = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, value);\n      if (status) _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n      if (_classPrivateFieldGet(this, _isStale).call(this, index)) {\n        if (status) status.get = 'stale';\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k);\n          }\n          if (status && allowStale) status.returnedStale = true;\n          return allowStale ? value : undefined;\n        } else {\n          if (status && allowStale && value.__staleWhileFetching !== undefined) {\n            status.returnedStale = true;\n          }\n          return allowStale ? value.__staleWhileFetching : undefined;\n        }\n      } else {\n        if (status) status.get = 'hit';\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching;\n        }\n        _classPrivateMethodGet(this, _moveToTail, _moveToTail2).call(this, index);\n        if (updateAgeOnGet) {\n          _classPrivateFieldGet(this, _updateItemAge).call(this, index);\n        }\n        return value;\n      }\n    } else if (status) {\n      status.get = 'miss';\n    }\n  }\n  /**\n   * Deletes a key out of the cache.\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k) {\n    let deleted = false;\n    if (_classPrivateFieldGet(this, _size) !== 0) {\n      const index = _classPrivateFieldGet(this, _keyMap).get(k);\n      if (index !== undefined) {\n        deleted = true;\n        if (_classPrivateFieldGet(this, _size) === 1) {\n          this.clear();\n        } else {\n          var _this$size5, _this$size6;\n          _classPrivateFieldGet(this, _removeItemSize).call(this, index);\n          const v = _classPrivateFieldGet(this, _valList)[index];\n          if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n            v.__abortController.abort(new Error('deleted'));\n          } else if (_classPrivateFieldGet(this, _hasDispose) || _classPrivateFieldGet(this, _hasDisposeAfter)) {\n            if (_classPrivateFieldGet(this, _hasDispose)) {\n              _classPrivateFieldGet(this, _dispose)?.call(this, v, k, 'delete');\n            }\n            if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n              _classPrivateFieldGet(this, _disposed)?.push([v, k, 'delete']);\n            }\n          }\n          _classPrivateFieldGet(this, _keyMap).delete(k);\n          _classPrivateFieldGet(this, _keyList)[index] = undefined;\n          _classPrivateFieldGet(this, _valList)[index] = undefined;\n          if (index === _classPrivateFieldGet(this, _tail)) {\n            _classPrivateFieldSet(this, _tail, _classPrivateFieldGet(this, _prev)[index]);\n          } else if (index === _classPrivateFieldGet(this, _head)) {\n            _classPrivateFieldSet(this, _head, _classPrivateFieldGet(this, _next)[index]);\n          } else {\n            _classPrivateFieldGet(this, _next)[_classPrivateFieldGet(this, _prev)[index]] = _classPrivateFieldGet(this, _next)[index];\n            _classPrivateFieldGet(this, _prev)[_classPrivateFieldGet(this, _next)[index]] = _classPrivateFieldGet(this, _prev)[index];\n          }\n          _classPrivateFieldSet(this, _size, (_this$size5 = _classPrivateFieldGet(this, _size), _this$size6 = _this$size5--, _this$size5)), _this$size6;\n          _classPrivateFieldGet(this, _free).push(index);\n        }\n      }\n    }\n    if (_classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)?.length) {\n      const dt = _classPrivateFieldGet(this, _disposed);\n      let task;\n      while (task = dt?.shift()) {\n        _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n      }\n    }\n    return deleted;\n  }\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    for (const index of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this, {\n      allowStale: true\n    })) {\n      const v = _classPrivateFieldGet(this, _valList)[index];\n      if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n        v.__abortController.abort(new Error('deleted'));\n      } else {\n        const k = _classPrivateFieldGet(this, _keyList)[index];\n        if (_classPrivateFieldGet(this, _hasDispose)) {\n          _classPrivateFieldGet(this, _dispose)?.call(this, v, k, 'delete');\n        }\n        if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n          _classPrivateFieldGet(this, _disposed)?.push([v, k, 'delete']);\n        }\n      }\n    }\n    _classPrivateFieldGet(this, _keyMap).clear();\n    _classPrivateFieldGet(this, _valList).fill(undefined);\n    _classPrivateFieldGet(this, _keyList).fill(undefined);\n    if (_classPrivateFieldGet(this, _ttls) && _classPrivateFieldGet(this, _starts)) {\n      _classPrivateFieldGet(this, _ttls).fill(0);\n      _classPrivateFieldGet(this, _starts).fill(0);\n    }\n    if (_classPrivateFieldGet(this, _sizes)) {\n      _classPrivateFieldGet(this, _sizes).fill(0);\n    }\n    _classPrivateFieldSet(this, _head, 0);\n    _classPrivateFieldSet(this, _tail, 0);\n    _classPrivateFieldGet(this, _free).length = 0;\n    _classPrivateFieldSet(this, _calculatedSize, 0);\n    _classPrivateFieldSet(this, _size, 0);\n    if (_classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)) {\n      const dt = _classPrivateFieldGet(this, _disposed);\n      let task;\n      while (task = dt?.shift()) {\n        _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n      }\n    }\n  }\n}\nfunction _initializeTTLTracking2() {\n  const ttls = new ZeroArray(_classPrivateFieldGet(this, _max));\n  const starts = new ZeroArray(_classPrivateFieldGet(this, _max));\n  _classPrivateFieldSet(this, _ttls, ttls);\n  _classPrivateFieldSet(this, _starts, starts);\n  _classPrivateFieldSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {\n    starts[index] = ttl !== 0 ? start : 0;\n    ttls[index] = ttl;\n    if (ttl !== 0 && this.ttlAutopurge) {\n      const t = setTimeout(() => {\n        if (_classPrivateFieldGet(this, _isStale).call(this, index)) {\n          this.delete(_classPrivateFieldGet(this, _keyList)[index]);\n        }\n      }, ttl + 1);\n      // unref() not supported on all platforms\n      /* c8 ignore start */\n      if (t.unref) {\n        t.unref();\n      }\n      /* c8 ignore stop */\n    }\n  });\n\n  _classPrivateFieldSet(this, _updateItemAge, index => {\n    starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n  });\n  _classPrivateFieldSet(this, _statusTTL, (status, index) => {\n    if (ttls[index]) {\n      const ttl = ttls[index];\n      const start = starts[index];\n      status.ttl = ttl;\n      status.start = start;\n      status.now = cachedNow || getNow();\n      status.remainingTTL = status.now + ttl - start;\n    }\n  });\n  // debounce calls to perf.now() to 1s so we're not hitting\n  // that costly call repeatedly.\n  let cachedNow = 0;\n  const getNow = () => {\n    const n = perf.now();\n    if (this.ttlResolution > 0) {\n      cachedNow = n;\n      const t = setTimeout(() => cachedNow = 0, this.ttlResolution);\n      // not available on all platforms\n      /* c8 ignore start */\n      if (t.unref) {\n        t.unref();\n      }\n      /* c8 ignore stop */\n    }\n\n    return n;\n  };\n  this.getRemainingTTL = key => {\n    const index = _classPrivateFieldGet(this, _keyMap).get(key);\n    if (index === undefined) {\n      return 0;\n    }\n    return ttls[index] === 0 || starts[index] === 0 ? Infinity : starts[index] + ttls[index] - (cachedNow || getNow());\n  };\n  _classPrivateFieldSet(this, _isStale, index => {\n    return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];\n  });\n}\nfunction _initializeSizeTracking2() {\n  const sizes = new ZeroArray(_classPrivateFieldGet(this, _max));\n  _classPrivateFieldSet(this, _calculatedSize, 0);\n  _classPrivateFieldSet(this, _sizes, sizes);\n  _classPrivateFieldSet(this, _removeItemSize, index => {\n    _classPrivateFieldSet(this, _calculatedSize, _classPrivateFieldGet(this, _calculatedSize) - sizes[index]);\n    sizes[index] = 0;\n  });\n  _classPrivateFieldSet(this, _requireSize, (k, v, size, sizeCalculation) => {\n    // provisionally accept background fetches.\n    // actual value size will be checked when they return.\n    if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n      return 0;\n    }\n    if (!isPosInt(size)) {\n      if (sizeCalculation) {\n        if (typeof sizeCalculation !== 'function') {\n          throw new TypeError('sizeCalculation must be a function');\n        }\n        size = sizeCalculation(v, k);\n        if (!isPosInt(size)) {\n          throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n        }\n      } else {\n        throw new TypeError('invalid size value (must be positive integer). ' + 'When maxSize or maxEntrySize is used, sizeCalculation ' + 'or size must be set.');\n      }\n    }\n    return size;\n  });\n  _classPrivateFieldSet(this, _addItemSize, (index, size, status) => {\n    sizes[index] = size;\n    if (_classPrivateFieldGet(this, _maxSize)) {\n      const maxSize = _classPrivateFieldGet(this, _maxSize) - sizes[index];\n      while (_classPrivateFieldGet(this, _calculatedSize) > maxSize) {\n        _classPrivateMethodGet(this, _evict, _evict2).call(this, true);\n      }\n    }\n    _classPrivateFieldSet(this, _calculatedSize, _classPrivateFieldGet(this, _calculatedSize) + sizes[index]);\n    if (status) {\n      status.entrySize = size;\n      status.totalCalculatedSize = _classPrivateFieldGet(this, _calculatedSize);\n    }\n  });\n}\nfunction* _indexes2({\n  allowStale = this.allowStale\n} = {}) {\n  if (_classPrivateFieldGet(this, _size)) {\n    for (let i = _classPrivateFieldGet(this, _tail); true;) {\n      if (!_classPrivateMethodGet(this, _isValidIndex, _isValidIndex2).call(this, i)) {\n        break;\n      }\n      if (allowStale || !_classPrivateFieldGet(this, _isStale).call(this, i)) {\n        yield i;\n      }\n      if (i === _classPrivateFieldGet(this, _head)) {\n        break;\n      } else {\n        i = _classPrivateFieldGet(this, _prev)[i];\n      }\n    }\n  }\n}\nfunction* _rindexes2({\n  allowStale = this.allowStale\n} = {}) {\n  if (_classPrivateFieldGet(this, _size)) {\n    for (let i = _classPrivateFieldGet(this, _head); true;) {\n      if (!_classPrivateMethodGet(this, _isValidIndex, _isValidIndex2).call(this, i)) {\n        break;\n      }\n      if (allowStale || !_classPrivateFieldGet(this, _isStale).call(this, i)) {\n        yield i;\n      }\n      if (i === _classPrivateFieldGet(this, _tail)) {\n        break;\n      } else {\n        i = _classPrivateFieldGet(this, _next)[i];\n      }\n    }\n  }\n}\nfunction _isValidIndex2(index) {\n  return index !== undefined && _classPrivateFieldGet(this, _keyMap).get(_classPrivateFieldGet(this, _keyList)[index]) === index;\n}\nfunction _evict2(free) {\n  var _this$size3, _this$size4;\n  const head = _classPrivateFieldGet(this, _head);\n  const k = _classPrivateFieldGet(this, _keyList)[head];\n  const v = _classPrivateFieldGet(this, _valList)[head];\n  if (_classPrivateFieldGet(this, _hasFetchMethod) && _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n    v.__abortController.abort(new Error('evicted'));\n  } else if (_classPrivateFieldGet(this, _hasDispose) || _classPrivateFieldGet(this, _hasDisposeAfter)) {\n    if (_classPrivateFieldGet(this, _hasDispose)) {\n      _classPrivateFieldGet(this, _dispose)?.call(this, v, k, 'evict');\n    }\n    if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n      _classPrivateFieldGet(this, _disposed)?.push([v, k, 'evict']);\n    }\n  }\n  _classPrivateFieldGet(this, _removeItemSize).call(this, head);\n  // if we aren't about to use the index, then null these out\n  if (free) {\n    _classPrivateFieldGet(this, _keyList)[head] = undefined;\n    _classPrivateFieldGet(this, _valList)[head] = undefined;\n    _classPrivateFieldGet(this, _free).push(head);\n  }\n  if (_classPrivateFieldGet(this, _size) === 1) {\n    _classPrivateFieldSet(this, _head, _classPrivateFieldSet(this, _tail, 0));\n    _classPrivateFieldGet(this, _free).length = 0;\n  } else {\n    _classPrivateFieldSet(this, _head, _classPrivateFieldGet(this, _next)[head]);\n  }\n  _classPrivateFieldGet(this, _keyMap).delete(k);\n  _classPrivateFieldSet(this, _size, (_this$size3 = _classPrivateFieldGet(this, _size), _this$size4 = _this$size3--, _this$size3)), _this$size4;\n  return head;\n}\nfunction _backgroundFetch2(k, index, options, context) {\n  const v = index === undefined ? undefined : _classPrivateFieldGet(this, _valList)[index];\n  if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n    return v;\n  }\n  const ac = new AbortController();\n  const {\n    signal\n  } = options;\n  // when/if our AC signals, then stop listening to theirs.\n  signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n    signal: ac.signal\n  });\n  const fetchOpts = {\n    signal: ac.signal,\n    options,\n    context\n  };\n  const cb = (v, updateCache = false) => {\n    const {\n      aborted\n    } = ac.signal;\n    const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n    if (options.status) {\n      if (aborted && !updateCache) {\n        options.status.fetchAborted = true;\n        options.status.fetchError = ac.signal.reason;\n        if (ignoreAbort) options.status.fetchAbortIgnored = true;\n      } else {\n        options.status.fetchResolved = true;\n      }\n    }\n    if (aborted && !ignoreAbort && !updateCache) {\n      return fetchFail(ac.signal.reason);\n    }\n    // either we didn't abort, and are still here, or we did, and ignored\n    const bf = p;\n    if (_classPrivateFieldGet(this, _valList)[index] === p) {\n      if (v === undefined) {\n        if (bf.__staleWhileFetching) {\n          _classPrivateFieldGet(this, _valList)[index] = bf.__staleWhileFetching;\n        } else {\n          this.delete(k);\n        }\n      } else {\n        if (options.status) options.status.fetchUpdated = true;\n        this.set(k, v, fetchOpts.options);\n      }\n    }\n    return v;\n  };\n  const eb = er => {\n    if (options.status) {\n      options.status.fetchRejected = true;\n      options.status.fetchError = er;\n    }\n    return fetchFail(er);\n  };\n  const fetchFail = er => {\n    const {\n      aborted\n    } = ac.signal;\n    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n    const noDelete = allowStale || options.noDeleteOnFetchRejection;\n    const bf = p;\n    if (_classPrivateFieldGet(this, _valList)[index] === p) {\n      // if we allow stale on fetch rejections, then we need to ensure that\n      // the stale value is not removed from the cache when the fetch fails.\n      const del = !noDelete || bf.__staleWhileFetching === undefined;\n      if (del) {\n        this.delete(k);\n      } else if (!allowStaleAborted) {\n        // still replace the *promise* with the stale value,\n        // since we are done with the promise at this point.\n        // leave it untouched if we're still waiting for an\n        // aborted background fetch that hasn't yet returned.\n        _classPrivateFieldGet(this, _valList)[index] = bf.__staleWhileFetching;\n      }\n    }\n    if (allowStale) {\n      if (options.status && bf.__staleWhileFetching !== undefined) {\n        options.status.returnedStale = true;\n      }\n      return bf.__staleWhileFetching;\n    } else if (bf.__returned === bf) {\n      throw er;\n    }\n  };\n  const pcall = (res, rej) => {\n    const fmp = _classPrivateFieldGet(this, _fetchMethod)?.call(this, k, v, fetchOpts);\n    if (fmp && fmp instanceof Promise) {\n      fmp.then(v => res(v), rej);\n    }\n    // ignored, we go until we finish, regardless.\n    // defer check until we are actually aborting,\n    // so fetchMethod can override.\n    ac.signal.addEventListener('abort', () => {\n      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n        res();\n        // when it eventually resolves, update the cache.\n        if (options.allowStaleOnFetchAbort) {\n          res = v => cb(v, true);\n        }\n      }\n    });\n  };\n  if (options.status) options.status.fetchDispatched = true;\n  const p = new Promise(pcall).then(cb, eb);\n  const bf = Object.assign(p, {\n    __abortController: ac,\n    __staleWhileFetching: v,\n    __returned: undefined\n  });\n  if (index === undefined) {\n    // internal, don't expose status.\n    this.set(k, bf, {\n      ...fetchOpts.options,\n      status: undefined\n    });\n    index = _classPrivateFieldGet(this, _keyMap).get(k);\n  } else {\n    _classPrivateFieldGet(this, _valList)[index] = bf;\n  }\n  return bf;\n}\nfunction _isBackgroundFetch2(p) {\n  if (!_classPrivateFieldGet(this, _hasFetchMethod)) return false;\n  const b = p;\n  return !!b && b instanceof Promise && b.hasOwnProperty('__staleWhileFetching') && b.__abortController instanceof AbortController;\n}\nfunction _connect2(p, n) {\n  _classPrivateFieldGet(this, _prev)[n] = p;\n  _classPrivateFieldGet(this, _next)[p] = n;\n}\nfunction _moveToTail2(index) {\n  // if tail already, nothing to do\n  // if head, move head to next[index]\n  // else\n  //   move next[prev[index]] to next[index] (head has no prev)\n  //   move prev[next[index]] to prev[index]\n  // prev[index] = tail\n  // next[tail] = index\n  // tail = index\n  if (index !== _classPrivateFieldGet(this, _tail)) {\n    if (index === _classPrivateFieldGet(this, _head)) {\n      _classPrivateFieldSet(this, _head, _classPrivateFieldGet(this, _next)[index]);\n    } else {\n      _classPrivateMethodGet(this, _connect, _connect2).call(this, _classPrivateFieldGet(this, _prev)[index], _classPrivateFieldGet(this, _next)[index]);\n    }\n    _classPrivateMethodGet(this, _connect, _connect2).call(this, _classPrivateFieldGet(this, _tail), index);\n    _classPrivateFieldSet(this, _tail, index);\n  }\n}\nexports.LRUCache = LRUCache;\nexports.default = LRUCache;","map":{"version":3,"names":["_asyncToGenerator","require","default","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateFieldSet","_classPrivateMethodGet","_classPrivateFieldGet","_defineProperty","_classStaticPrivateFieldSpecGet","_classStaticPrivateFieldSpecSet","_Symbol$iterator","Object","defineProperty","exports","value","LRUCache","perf","performance","now","Date","warned","Set","emitWarning","msg","type","code","fn","process","console","error","shouldWarn","has","TYPE","Symbol","isPosInt","n","Math","floor","isFinite","getUintArray","max","pow","Uint8Array","Uint16Array","Uint32Array","Number","MAX_SAFE_INTEGER","ZeroArray","Array","constructor","size","fill","Stack","create","HeapCls","_constructing","s","TypeError","heap","length","push","pop","writable","_max","WeakMap","_maxSize","_dispose","_disposeAfter","_fetchMethod","_size","_calculatedSize","_keyMap","_keyList","_valList","_next","_prev","_head","_tail","_free","_disposed","_sizes","_starts","_ttls","_hasDispose","_hasFetchMethod","_hasDisposeAfter","_initializeTTLTracking","WeakSet","_updateItemAge","_statusTTL","_setItemTTL","_isStale","_initializeSizeTracking","_removeItemSize","_addItemSize","_requireSize","_indexes","_rindexes","_isValidIndex","_evict","_backgroundFetch","_isBackgroundFetch","_connect","_moveToTail","iterator","unsafeExposeInternals","c","starts","ttls","sizes","keyMap","keyList","valList","next","prev","head","tail","free","isBackgroundFetch","p","_isBackgroundFetch2","call","backgroundFetch","k","index","options","context","_backgroundFetch2","moveToTail","_moveToTail2","indexes","_indexes2","rindexes","_rindexes2","isStale","maxSize","calculatedSize","fetchMethod","dispose","disposeAfter","_i","_s","_st","_k","_v","sizeCalculation","ttl","ttlResolution","ttlAutopurge","updateAgeOnGet","updateAgeOnHas","allowStale","noDisposeOnSet","noUpdateTTL","maxEntrySize","noDeleteOnFetchRejection","noDeleteOnStaleGet","allowStaleOnFetchRejection","allowStaleOnFetchAbort","ignoreFetchAbort","UintArray","Error","undefined","Map","_initializeSizeTracking2","_initializeTTLTracking2","add","getRemainingTTL","key","Infinity","entries","i","rentries","keys","rkeys","values","v","rvalues","find","getOptions","__staleWhileFetching","get","forEach","thisp","rforEach","purgeStale","deleted","delete","dump","arr","entry","age","start","unshift","load","clear","set","setOptions","status","maxEntrySizeExceeded","_this$size","_this$size2","_evict2","oldVal","__abortController","abort","oldValue","dt","task","shift","val","hasOptions","peek","peekOptions","fetch","fetchOptions","_this","forceRefresh","signal","__returned","stale","returnedStale","hasStale","staleVal","fetching","_this$size5","_this$size6","t","setTimeout","unref","cachedNow","getNow","remainingTTL","entrySize","totalCalculatedSize","_isValidIndex2","_this$size3","_this$size4","ac","AbortController","addEventListener","reason","fetchOpts","cb","updateCache","aborted","ignoreAbort","fetchAborted","fetchError","fetchAbortIgnored","fetchResolved","fetchFail","bf","fetchUpdated","eb","er","fetchRejected","allowStaleAborted","noDelete","del","pcall","res","rej","fmp","Promise","then","fetchDispatched","assign","b","hasOwnProperty","_connect2"],"sources":["C:/Users/User/Desktop/frontend/LoginApp/node_modules/mysql2/node_modules/lru-cache/dist/cjs/index.js"],"sourcesContent":["\"use strict\";\n/**\n * @module LRUCache\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LRUCache = void 0;\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\nconst emitWarning = (msg, type, code, fn) => {\n    typeof process === 'object' &&\n        process &&\n        typeof process.emitWarning === 'function'\n        ? process.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\nclass LRUCache {\n    // properties coming in from the options of these, only max and maxSize\n    // really *need* to be protected. The rest can be modified, as they just\n    // set defaults for various methods.\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the remaining TTL time for a given entry key\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.delete(this.#keyList[index]);\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                status.remainingTTL = status.now + ttl - start;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            return ttls[index] === 0 || starts[index] === 0\n                ? Infinity\n                : starts[index] + ttls[index] - (cachedNow || getNow());\n        };\n        this.#isStale = index => {\n            return (ttls[index] !== 0 &&\n                starts[index] !== 0 &&\n                (cachedNow || getNow()) - starts[index] > ttls[index]);\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to Array.find().  fn is called as fn(value, key, cache).\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from\n     * most recently used to least recently used.  fn is called as\n     * fn(value, key, cache).  Does not update age or recenty of use.\n     * Does not iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.delete(this.#keyList[i]);\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to cache.load()\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     * Note that the shape of the resulting cache may be different if the\n     * same options are not used in both caches.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     */\n    set(k, v, setOptions = {}) {\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.delete(k);\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined &&\n            (allowStale || !this.#isStale(index))) {\n            const v = this.#valList[index];\n            // either stale and allowed, or forcing a refresh of non-stale value\n            return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n        }\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AbortController();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.delete(k);\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.delete(k);\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res();\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AbortController);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.delete(k);\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.clear();\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, 'delete');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, 'delete']);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        this.#next[this.#prev[index]] = this.#next[index];\n                        this.#prev[this.#next[index]] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, 'delete');\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, 'delete']);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\nexports.LRUCache = LRUCache;\nexports.default = LRUCache;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}